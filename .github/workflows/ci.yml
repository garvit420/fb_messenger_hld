# =============================================================================
# CI Pipeline - Continuous Integration for FB Messenger Backend
# =============================================================================
# This pipeline runs on every push/PR to main branch and includes:
# 1. Code quality checks (linting with flake8 & black)
# 2. Security scanning (CodeQL SAST, pip-audit SCA, Trivy container scan)
# 3. Unit testing with pytest
# 4. Docker image build and push to DockerHub
# =============================================================================

name: CI Pipeline

# -----------------------------------------------------------------------------
# TRIGGERS: When should this pipeline run?
# - Push to main: Run full pipeline including Docker push
# - Pull requests: Run all checks but skip Docker push (for review)
# - Manual trigger: Allow manual runs for debugging
# -----------------------------------------------------------------------------
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allows manual triggering from GitHub UI

# -----------------------------------------------------------------------------
# ENVIRONMENT VARIABLES: Shared across all jobs
# -----------------------------------------------------------------------------
env:
  PYTHON_VERSION: "3.11"
  DOCKER_IMAGE: ${{ secrets.DOCKERHUB_USERNAME }}/fb-messenger-backend

# -----------------------------------------------------------------------------
# JOBS: Define the pipeline stages
# -----------------------------------------------------------------------------
jobs:
  # ===========================================================================
  # JOB 1: Code Quality & Linting
  # WHY: Enforce consistent code style and catch common errors early
  # ===========================================================================
  lint:
    name: Code Quality & Linting
    runs-on: ubuntu-latest

    steps:
      # Step 1.1: Checkout code from repository
      # WHY: Need source code to analyze
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 1.2: Setup Python environment
      # WHY: Need Python runtime to run linting tools
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Step 1.3: Cache pip dependencies
      # WHY: Speed up subsequent builds by caching installed packages
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-lint-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-lint-
            ${{ runner.os }}-pip-

      # Step 1.4: Install linting tools
      # WHY: Need flake8 for PEP8 compliance, black for formatting check
      - name: Install linting tools
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black

      # Step 1.5: Run flake8 linter
      # WHY: Checks for PEP8 compliance, syntax errors, and code complexity
      - name: Run flake8
        run: |
          flake8 app/ tests/ --count --show-source --statistics

      # Step 1.6: Check code formatting with black
      # WHY: Ensures consistent code formatting across the codebase
      - name: Check formatting with black
        run: |
          black --check --diff app/ tests/

  # ===========================================================================
  # JOB 2: SAST - Static Application Security Testing with CodeQL
  # WHY: Detect security vulnerabilities in source code (OWASP Top 10)
  # Examples: SQL injection, XSS, insecure deserialization
  # ===========================================================================
  sast:
    name: SAST - CodeQL Security Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write  # Required to upload SARIF results

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Initialize CodeQL for Python analysis
      # WHY: CodeQL builds a database of code semantics for deep analysis
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: python
          # Use default queries plus security-extended for comprehensive coverage
          queries: security-extended

      # Perform the CodeQL analysis
      # WHY: Scans code against known vulnerability patterns
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:python"

  # ===========================================================================
  # JOB 3: SCA - Software Composition Analysis
  # WHY: Identify known vulnerabilities in third-party dependencies
  # Critical for supply-chain security (e.g., Log4Shell, Heartbleed)
  # ===========================================================================
  sca:
    name: SCA - Dependency Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Install pip-audit for dependency scanning
      # WHY: pip-audit checks PyPI packages against known vulnerability databases
      - name: Install pip-audit
        run: |
          python -m pip install --upgrade pip
          pip install pip-audit

      # Install project dependencies (needed for pip-audit to analyze)
      - name: Install dependencies
        run: |
          pip install -r requirements.txt

      # Run pip-audit to check for vulnerable packages
      # WHY: Fails the build if any dependency has known CVEs
      - name: Run pip-audit
        run: |
          pip-audit --strict --desc on

  # ===========================================================================
  # JOB 4: Unit Tests with pytest
  # WHY: Validate business logic and prevent regressions
  # Tests are the safety net that catches bugs before production
  # ===========================================================================
  test:
    name: Unit Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-test-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-test-
            ${{ runner.os }}-pip-

      # Install all dependencies including test dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio

      # Run pytest with coverage reporting
      # WHY: Coverage helps identify untested code paths
      - name: Run tests with coverage
        run: |
          pytest tests/ -v --cov=app --cov-report=xml --cov-report=term-missing

      # Upload coverage report as artifact
      # WHY: Allows viewing coverage in GitHub Actions UI
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage.xml
          retention-days: 7

  # ===========================================================================
  # JOB 5: Build & Push Docker Image
  # WHY: Create immutable container image for consistent deployments
  # Only pushes to registry after ALL quality gates pass
  # ===========================================================================
  docker:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    # IMPORTANT: Only run after all quality gates pass
    needs: [lint, sast, sca, test]
    permissions:
      contents: read
      security-events: write  # Required to upload Trivy SARIF results

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Setup Docker Buildx for advanced build features
      # WHY: Enables multi-platform builds and better caching
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Login to DockerHub (only for push events, not PRs)
      # WHY: Need authentication to push images to registry
      - name: Login to DockerHub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Generate image tags
      # WHY: Tag with both 'latest' and commit SHA for versioning
      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=,format=short

      # Build Docker image (and push if not a PR)
      # WHY: Create the container image from Dockerfile
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # =========================================================================
      # TRIVY: Container Image Vulnerability Scanner
      # WHY: Scans OS packages and application dependencies in the built image
      # Catches vulnerabilities that pip-audit might miss (OS-level issues)
      # =========================================================================
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_IMAGE }}:latest
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
        # Only run Trivy if image was built (not on PR where push=false)
        if: github.event_name != 'pull_request'

      # Upload Trivy results to GitHub Security tab
      # WHY: Integrates with GitHub's security dashboard for visibility
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        if: github.event_name != 'pull_request'

  # ===========================================================================
  # JOB 6: Container Smoke Test
  # WHY: Verify the built image actually runs and responds to requests
  # Catches runtime issues that static analysis can't detect
  # ===========================================================================
  container-test:
    name: Container Smoke Test
    runs-on: ubuntu-latest
    needs: [docker]
    if: github.event_name != 'pull_request'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Pull and run the built image
      - name: Run container
        run: |
          docker pull ${{ env.DOCKER_IMAGE }}:latest
          docker run -d --name test-container -p 8000:8000 ${{ env.DOCKER_IMAGE }}:latest
          sleep 10  # Wait for container to start

      # Test the health endpoint
      # WHY: Verify the application is running and responding
      - name: Test health endpoint
        run: |
          curl --fail http://localhost:8000/health || exit 1
          echo "Health check passed!"

      # Test the API docs endpoint
      - name: Test API docs endpoint
        run: |
          curl --fail http://localhost:8000/docs || exit 1
          echo "API docs accessible!"

      # Cleanup
      - name: Cleanup
        if: always()
        run: |
          docker stop test-container || true
          docker rm test-container || true
